{
  "hash": "2f6ce1def00ebd670669f216ce37417f",
  "result": {
    "markdown": "## Tasks and inputs {#w1-tasks-and-inputs}\n\n\n\n\n\nBefore starting with the task:\n\n1. Make sure you have read and followed the instructions in section [Preparation](#w0-preparation)\n2. In RStudio, open the RStudio Project you created for this week. You can see that you are in an RStudio Project if the project's name is visible next to the little RStudio logo in the top right corner of RStudio (otherwise it will read `Project: (None)`).\n3. Download the wildboar movement data here: [wildschwein_BE.csv](https://moodle.zhaw.ch/pluginfile.php/1168373/mod_folder/content/0/wildschwein_BE.csv?forcedownload=1)\n\n###### Once you have set everything up, commit your file to your git repo in the following manner: {#sec-commit}\n\n:::{.callout-note}\n\n## Committing files with git\n\n1. Save your (R/RMarkdown/Quarto) file\n2. Switch to the \"Git\"-Tab in the pane in the top right corner\n3. Click \"commit\" to open the \"Commit Window\"\n4. Click in the checkbox next to the file(s) you want to commit\n5. Add a commit message to explain what you are committing (e.g. \"`initial commit`\")\n6. Click on \"commit\" to commit your changes\n\n:::\n\n### Task 1: Import data\n\nCreate a new R- (or qmd) file and begin by loading the following packages: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"readr\") # to import tabular data (e.g. csv)\nlibrary(\"dplyr\") # to manipulate (tabular) data\nlibrary(\"ggplot2\") # to visualize data\n```\n:::\n\n\nMove the file `wildschwein_BE.csv` into your project directory and import it into `r` as a `data.frame`. Assign correct column types as necessary and make sure the time zone is set correctly for the date/time column.\n\nNote: We recommend using the `readr` package to import data[^readr]. These functions have an underscore in their name, e.g. `read_csv` in oppose to the base `R` functions, which have a period (e.g. `read.csv`). Specifically for the wild boar data, we recommend `read_delim()`.\n\n\n[^readr]: Our reasons for preferring `readr` over base-R import functions:\n\n    1. ~~base `R` imports strings as factors by default~~ (since R 4.0.0, this is not the case anymore)\n    2. `readr` is generally faster (which only matters if you have a large dataset)\n    3. `readr` makes safer assumptins about your data (e.g. the default timezone for datetime columns is UTC)\n    4. `data.frames` created by `readr` are prettier when printed to the console and contain more information using less characters\n\n    HOWEVER: Using external libraries (such as `readr`) creates additional dependencies which has it's own downsides (which is one of the reasons we don't do `library(\"tidyverse\")`). \n\n\n\n\n\n\n\n\nCommit your changes as described [in the beginning](#sec-commit). Write a meaningful commit message (e.g. \"`completed task 1`\").\n\n### Task 2: Explore Data\n\nWe will use a range of different visualization tools (i.e. R-packages) in this course. Several packages techniques have emerged in recent years, each with their specific strengths and weaknesses. While `base::plot() `is quick and simple, it not very scalable with growing complexity. `ggplot2` offers solutions for most use cases and has an elegant, consistent syntax that is easy to get accustomed to. We will get to know other techniques later in the course.\n\nGet an overview of your data by creating a first \"map-like\" plot of your data producing a simple scatter plot with `ggplot2`. \nSetting up a `ggplot` with our data is done using the command `ggplot(wildschwein_BE, aes(Long, Lat, colour = TierID))`. Creating a map is done via the basic scatter plot command `geom_point()`. \n\nCommit your changes as described [in the beginning](#sec-commit). Have a look at your commit history by clicking on \"History\" in the \"Git\"-Pane.\n\n\n::: {.cell file='solutions/week1/task_2.R'}\n::: {.cell-output-display}\n![Your plot should look something like this.](W1_5_tasks_and_inputs_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n### Input: Handling spatial data\n\nUntil now, we've stored our location data within data frames as Lat/Long columns. This works well for many tasks, but sometimes we need special *spatial* classes to handle our trajectories. We will get to know such cases in our next tasks, but first we need to convert our `data.frame` into a spatial object.\n\nWe will largely rely on `sf`when working with vector data in `R`. In order to transform our `data.frame` into an sf object, we need to use the function `st_as_sf()` while specifying the columns storing the coordinates and the coordinate reference system.\n\n(At this point, we assume you know what a Coordinate Reference Systems is. Check out [this link](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/intro-to-coordinate-reference-systems/) if this is not the case.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"sf\")\n\nwildschwein_BE_sf <- st_as_sf(wildschwein_BE,\n    coords = c(\"Long\", \"Lat\"),\n    crs = 4326\n)\n```\n:::\n\n\nNotice how `st_as_sf` takes the EPSG code for the `crs =` argument. You can find a lot of useful information on Coordinate Reference Systems (including EPSG Codes, etc.) under [epsg.io](http://epsg.io).  \nLet's compare our original `data.frame` with this new `sf` object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein_BE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 51,246 × 6\n   TierID TierName CollarID DatetimeUTC           Lat  Long\n   <chr>  <chr>       <dbl> <dttm>              <dbl> <dbl>\n 1 002A   Sabi        12275 2014-08-22 21:00:12  47.0  7.05\n 2 002A   Sabi        12275 2014-08-22 21:15:16  47.0  7.05\n 3 002A   Sabi        12275 2014-08-22 21:30:43  47.0  7.05\n 4 002A   Sabi        12275 2014-08-22 21:46:07  47.0  7.05\n 5 002A   Sabi        12275 2014-08-22 22:00:22  47.0  7.05\n 6 002A   Sabi        12275 2014-08-22 22:15:10  47.0  7.05\n 7 002A   Sabi        12275 2014-08-22 22:30:13  47.0  7.05\n 8 002A   Sabi        12275 2014-08-22 22:45:11  47.0  7.05\n 9 002A   Sabi        12275 2014-08-22 23:00:27  47.0  7.05\n10 002A   Sabi        12275 2014-08-22 23:15:41  47.0  7.05\n# ℹ 51,236 more rows\n```\n:::\n\n```{.r .cell-code}\nwildschwein_BE_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 51246 features and 4 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 7.019889 ymin: 46.97125 xmax: 7.112075 ymax: 47.01882\nGeodetic CRS:  WGS 84\n# A tibble: 51,246 × 5\n   TierID TierName CollarID DatetimeUTC                    geometry\n * <chr>  <chr>       <dbl> <dttm>                      <POINT [°]>\n 1 002A   Sabi        12275 2014-08-22 21:00:12 (7.049618 46.99317)\n 2 002A   Sabi        12275 2014-08-22 21:15:16 (7.049509 46.99416)\n 3 002A   Sabi        12275 2014-08-22 21:30:43 (7.049406 46.99383)\n 4 002A   Sabi        12275 2014-08-22 21:46:07 (7.049217 46.99375)\n 5 002A   Sabi        12275 2014-08-22 22:00:22 (7.049359 46.99375)\n 6 002A   Sabi        12275 2014-08-22 22:15:10 (7.049363 46.99382)\n 7 002A   Sabi        12275 2014-08-22 22:30:13 (7.049326 46.99387)\n 8 002A   Sabi        12275 2014-08-22 22:45:11 (7.049237 46.99395)\n 9 002A   Sabi        12275 2014-08-22 23:00:27 (7.048383 46.99481)\n10 002A   Sabi        12275 2014-08-22 23:15:41 (7.049396 46.99373)\n# ℹ 51,236 more rows\n```\n:::\n:::\n\n\nAs you can see, `st_as_sf()` has added some metadata to our dataframe (`Geometry type`, `Dimension`, `Bounding box`, `Geodetic CRS`) and replaced the columns `Lat` and `Long` with a column named `geometry`. Other than that, the new `sf` object is very similar to our original dataframe. In fact, `sf` objects *are* essentially `dataframes`, as you can verify with the function `is.data.frame()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.data.frame(wildschwein_BE_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nAll operations we know from handling `data.frames` can be used on the `sf` object. Try some out!\n\n::: {.cell}\n\n```{.r .cell-code}\n# subset rows\nwildschwein_BE_sf[1:10, ]\nwildschwein_BE_sf[wildschwein_BE_sf$TierName == \"Sabi\", ]\n\n# subset colums\nwildschwein_BE_sf[, 2:3]\n```\n:::\n\n\nInstead of keeping the same data twice (once as a `data.frame`, and once as an `sf` object), we will overwrite the `data.frame` and continue working with the `sf` object from now on. This saves some memory space in `R` and avoids confusion. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein_BE <- st_as_sf(wildschwein_BE,\n    coords = c(\"Long\", \"Lat\"),\n    crs = 4326\n)\n\nrm(wildschwein_BE_sf)\n# we can remove this sf object, since it just eats up our memory\n```\n:::\n\n\n### Task 3: Project data from WGS84 {#sec-week1-task3-reproject}\n\nSo what can we do with our new `sf` object that we couldn't before? One example is projecting the WGS84 (`Lat`/`Long`) coordinates into the new Swiss CRS `CH1903+ LV95`[^50]. Do this by using the function `st_transform`. By the way, do you notice a pattern here? The package `sf` names most functions for spatial operations with the prefix `st_*`, just as in PostGIS.\n\n[^50]: As we've mentioned in the first Input, you can look up the EPSG codes under [epsg.io](http://epsg.io). For information specific to Switzerland, check the [swisstopo website](https://www.swisstopo.admin.ch/en/knowledge-facts/surveying-geodesy/reference-systems.html) \n\n\n\n\n\nHere's the resulting `sf` object from the operation:\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein_BE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 51246 features and 4 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609\nProjected CRS: CH1903+ / LV95\n# A tibble: 51,246 × 5\n   TierID TierName CollarID DatetimeUTC                  geometry\n * <chr>  <chr>       <dbl> <dttm>                    <POINT [m]>\n 1 002A   Sabi        12275 2014-08-22 21:00:12 (2570409 1204752)\n 2 002A   Sabi        12275 2014-08-22 21:15:16 (2570402 1204863)\n 3 002A   Sabi        12275 2014-08-22 21:30:43 (2570394 1204826)\n 4 002A   Sabi        12275 2014-08-22 21:46:07 (2570379 1204817)\n 5 002A   Sabi        12275 2014-08-22 22:00:22 (2570390 1204818)\n 6 002A   Sabi        12275 2014-08-22 22:15:10 (2570390 1204825)\n 7 002A   Sabi        12275 2014-08-22 22:30:13 (2570387 1204831)\n 8 002A   Sabi        12275 2014-08-22 22:45:11 (2570381 1204840)\n 9 002A   Sabi        12275 2014-08-22 23:00:27 (2570316 1204935)\n10 002A   Sabi        12275 2014-08-22 23:15:41 (2570393 1204815)\n# ℹ 51,236 more rows\n```\n:::\n:::\n\n\nCommit your changes as described [in the beginning](#sec-commit).\n\n### Input: Calculate Convex Hull\n\nTransforming from one Coordinate Reference System to another was one operation where we needed an object with a spatial nature. In this way, we were able to use an off-the-shelf function to project the coordinates from one CRS to another. In our next example, we again rely on a spatial function: We want to calculate a [convex hull](https://en.wikipedia.org/wiki/Convex_hull) per Wild boar. And guess what the function for calculating a convex hull is called in `sf`? If you guessed `st_convex_hull()`, you were right! \n\nBy default `st_convex_hull()` calculates the convex hull *per feature*, i.e. *per point* in our dataset. This of course makes little sense. In order to calculate the convex hull per animal, we need to convert our point- to multipoint-features where each feature contains all positions of one animal. This is achieved in two steps:\n\nFirst: add a grouping variable to the `sf` object. Note the new grouping variable in the metadata of the `sf` object. Other than that, `group_by` has no effect on our `sf` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein_BE_grouped <- group_by(wildschwein_BE, TierID)\n\nwildschwein_BE_grouped\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 51246 features and 4 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609\nProjected CRS: CH1903+ / LV95\n# A tibble: 51,246 × 5\n# Groups:   TierID [3]\n   TierID TierName CollarID DatetimeUTC                  geometry\n   <chr>  <chr>       <dbl> <dttm>                    <POINT [m]>\n 1 002A   Sabi        12275 2014-08-22 21:00:12 (2570409 1204752)\n 2 002A   Sabi        12275 2014-08-22 21:15:16 (2570402 1204863)\n 3 002A   Sabi        12275 2014-08-22 21:30:43 (2570394 1204826)\n 4 002A   Sabi        12275 2014-08-22 21:46:07 (2570379 1204817)\n 5 002A   Sabi        12275 2014-08-22 22:00:22 (2570390 1204818)\n 6 002A   Sabi        12275 2014-08-22 22:15:10 (2570390 1204825)\n 7 002A   Sabi        12275 2014-08-22 22:30:13 (2570387 1204831)\n 8 002A   Sabi        12275 2014-08-22 22:45:11 (2570381 1204840)\n 9 002A   Sabi        12275 2014-08-22 23:00:27 (2570316 1204935)\n10 002A   Sabi        12275 2014-08-22 23:15:41 (2570393 1204815)\n# ℹ 51,236 more rows\n```\n:::\n:::\n\n\nSecond: use `summarise()` to \"dissolve\" all points into a mulipoint object. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein_BE_smry <- summarise(wildschwein_BE_grouped)\n\nwildschwein_BE_smry\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 3 features and 1 field\nGeometry type: MULTIPOINT\nDimension:     XY\nBounding box:  xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609\nProjected CRS: CH1903+ / LV95\n# A tibble: 3 × 2\n  TierID                                                                geometry\n  <chr>                                                         <MULTIPOINT [m]>\n1 002A   ((2568903 1206200), (2568925 1206207), (2568980 1206197), (2569024 120…\n2 016A   ((2569231 1205823), (2569245 1205925), (2569247 1206027), (2569251 120…\n3 018A   ((2568153 1205611), (2568155 1205613), (2568161 1205624), (2568162 120…\n```\n:::\n:::\n\n\nNow we can run `st_convex_hull` on the new `sf` object. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcp <- st_convex_hull(wildschwein_BE_smry)\n```\n:::\n\n\n### Task 4: Ploting spatial objects\n\nUsing base plot to visualize `sf` objects is easy enough, just try the following code. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mcp)\n```\n\n::: {.cell-output-display}\n![](W1_5_tasks_and_inputs_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nBut since we use `ggplot` extensively, try and plot the object `mcp` with `ggplot`. Hint: Use the layer `geom_sf()` to add an `sf` object.\nNote: `ggplot` refuses to use our specified CRS, so we need to force this by specifying `datum = ` in `coord_sf()`. Try it out.\n\n\n\n\n\nCommit your changes as described [in the beginning](#sec-commit). Have a look at your commit history by clicking on \"History\" in the \"Git\"-Pane.\n\n### Input: Importing raster data {#w1-importing-raster}\n\nIn the next task, we would like to add a background map to our `mcp` object. Download the file here: [pk100_BE.tif](https://moodle.zhaw.ch/pluginfile.php/1168373/mod_folder/content/0/pk100_BE.tif?forcedownload=1)\nTo import the file into `R`, we use the package `terra` with the function `rast`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"terra\")\n\npk100_BE <- terra::rast(\"datasets/pk100_BE.tif\")\n\npk100_BE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 1821, 2321, 3  (nrow, ncol, nlyr)\nresolution  : 5, 5  (x, y)\nextent      : 2567000, 2578605, 1199996, 1209101  (xmin, xmax, ymin, ymax)\ncoord. ref. : CH1903+ / LV95 (EPSG:2056) \nsource      : pk100_BE.tif \nnames       : pk1_1, pk1_2, pk1_3 \nmin values  :     0,     0,     0 \nmax values  :   255,   255,   255 \n```\n:::\n:::\n\n\n`pk100_BE_2056.tif` is a three layered geotiff File. The above console output shows some metadata including the resolution, extent and the names of our layers (`pk1_1`, `pk1_2`etc). With the default `plot` method, each layer is displayed individually:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(pk100_BE)\n```\n\n::: {.cell-output-display}\n![](W1_5_tasks_and_inputs_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nWith `plotRGB` all three layers are combined into a single image:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotRGB(pk100_BE)\n```\n\n::: {.cell-output-display}\n![](W1_5_tasks_and_inputs_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n### Task 5: Adding a background map\n\nThere are multiple ways to add a background map in `ggplot`, many require additional packages. This is a good opportunity to get to know a completely different package for creating maps: `tmap` (\"thematic map\"). This package was developed with a syntax very similar to `ggplot2`, which makes it easy to learn.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tmap\")\n\ntm_shape(pk100_BE) +\n    tm_rgb()\n```\n\n::: {.cell-output-display}\n![](W1_5_tasks_and_inputs_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nAs you can see, plotting layers in `tmap` is combined with the `+` sign, just as in `ggplot2`. In `tmap` however, each layer consists of two objects: a `tm_shape()` in which the data is called, and a `tm_*` object in which we define how the data is visualized (`tm_rgb()` states that it is plotted as an RGB Raster Layer). Add the object `mcp` to the plot in this manner. Read [the vignette](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) if you are having trouble.\n\nCommit your changes as described [in the beginning](#sec-commit). Remember to add a meaningful commit message (e.g. `completed task 5`).\n\n\n::: {.cell file='solutions/week1/task_5.R'}\n::: {.cell-output-display}\n![](W1_5_tasks_and_inputs_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n### Task 6: Create an interactive map\n\nRerun the `tmap()...` command from the previous task, but switch the plotting mode to \"view\"\" (`tmap_mode(\"view\")`) beforehand. Omit the raster layer (`pk100_BE`), you won't be needing it.\n\nCommit your changes as described [in the beginning](#sec-commit). Have a look at your commit history by clicking on \"History\" in the \"Git\"-Pane.\n\n\n\n",
    "supporting": [
      "W1_5_tasks_and_inputs_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\r\n<script src=\"../site_libs/jquery-1.12.4/jquery.min.js\"></script>\r\n<link href=\"../site_libs/leaflet-1.3.1/leaflet.css\" rel=\"stylesheet\" />\r\n<script src=\"../site_libs/leaflet-1.3.1/leaflet.js\"></script>\r\n<link href=\"../site_libs/leafletfix-1.0.0/leafletfix.css\" rel=\"stylesheet\" />\r\n<script src=\"../site_libs/proj4-2.6.2/proj4.min.js\"></script>\r\n<script src=\"../site_libs/Proj4Leaflet-1.0.1/proj4leaflet.js\"></script>\r\n<link href=\"../site_libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css\" rel=\"stylesheet\" />\r\n<script src=\"../site_libs/leaflet-binding-2.1.2/leaflet.js\"></script>\r\n<script src=\"../site_libs/leaflet-providers-1.9.0/leaflet-providers_1.9.0.js\"></script>\r\n<script src=\"../site_libs/leaflet-providers-plugin-2.1.2/leaflet-providers-plugin.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}