{
  "hash": "86f034ad65fadfaf405c91d2e032afe3",
  "result": {
    "markdown": "## Solutions\n\n:::{.callout-tip}\nHover over the code and copy the content by clicking on the clipboard icon on the top right. You can now paste this into an R-Script.\n:::\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode .r}\n# task 1 ########################################################################\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\n\ncaro60 <- read_delim(\"datasets/caro60.csv\", \",\")\n\ncaro60 <- caro60 %>%\n  mutate(\n    stepMean = rowMeans(\n      cbind(\n        sqrt((lag(E, 3) - E)^2 + (lag(E, 3) - E)^2),\n        sqrt((lag(E, 2) - E)^2 + (lag(E, 2) - E)^2),\n        sqrt((lag(E, 1) - E)^2 + (lag(E, 1) - E)^2),\n        sqrt((E - lead(E, 1))^2 + (E - lead(E, 1))^2),\n        sqrt((E - lead(E, 2))^2 + (E - lead(E, 2))^2),\n        sqrt((E - lead(E, 3))^2 + (E - lead(E, 3))^2)\n      )\n    )\n  )\n\n# Note:\n# We present here a slightly different approach as presented in the input:\n# - cbind() creates a matrix with the same number of rows as the original dataframe\n# - It has 6 columns, one for each Euclidean distance calculation\n# - rowMeans() returns a single vector with the same number of rows as the original dataframe\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode .r}\n# task 2 ########################################################################\n\nsummary(caro60$stepMean)\n\nggplot(caro60, aes(stepMean)) +\n  geom_histogram(binwidth = 1) +\n  geom_vline(xintercept = mean(caro60$stepMean, na.rm = TRUE))\n\ncaro60 <- caro60 %>%\n  mutate(\n    static = stepMean < mean(caro60$stepMean, na.rm = TRUE)\n  )\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode .r}\n# task 3 ########################################################################\n\ncaro60 %>%\n  ggplot() +\n  geom_path(aes(E, N), alpha = 0.5) +\n  geom_point(aes(E, N, colour = static)) +\n  theme_minimal() +\n  coord_equal()\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode .r}\n# task 4 ########################################################################\n\ncaro60 <- caro60 %>%\n  mutate(\n    segment_ID = rle_id(static)\n  )\n\ncaro60_moves <- caro60 %>%\n  filter(!static)\n\np1 <- ggplot(caro60_moves, aes(E, N, color = segment_ID)) +\n  geom_point() +\n  geom_path() +\n  coord_equal() +\n  theme(legend.position = \"none\") +\n  labs(subtitle = \"All segments (uncleaned)\")\n\np2 <- caro60_moves %>%\n  group_by(segment_ID) %>%\n  mutate(duration = as.integer(difftime(max(DatetimeUTC), min(DatetimeUTC), \"mins\"))) %>%\n  filter(duration > 5) %>%\n  ggplot(aes(E, N, color = segment_ID)) +\n  # geom_point(data = caro60, color = \"black\") +\n  geom_point() +\n  geom_path() +\n  coord_equal() +\n  theme(legend.position = \"none\") +\n  labs(subtitle = \"Long segments (removed segements <5 minutes)\")\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode .r}\n# task 5 ########################################################################\n\npedestrians <- read_delim(\"datasets/pedestrian.csv\", \",\")\n\nggplot(pedestrians, aes(E, N)) +\n  geom_point(data = dplyr::select(pedestrians, -TrajID), alpha = 0.1) +\n  geom_point(aes(color = as.factor(TrajID)), size = 2) +\n  geom_path(aes(color = as.factor(TrajID))) +\n  facet_wrap(~TrajID, labeller = label_both) +\n  coord_equal() +\n  theme_minimal() +\n  labs(title = \"Visual comparison of the 6 trajectories\", subtitle = \"Each subplot highlights a trajectory\") +\n  theme(legend.position = \"none\")\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode .r}\n# task 6 ########################################################################\n\nlibrary(SimilarityMeasures) # for the similarity measure functions\n\n# all functions compare two trajectories (traj1 and traj2). Each trajectory\n# must be an numeric matrix of n dimensions. Since our dataset is spatiotemporal\n# we need to turn our Datetime column from POSIXct to integer:\n\npedestrians <- pedestrians %>%\n  mutate(Datetime_int = as.integer(DatetimeUTC))\n\n# Next, we make an object for each trajectory only containing the\n# coordinates in the three-dimensional space and turn it into a matrix\n\ntraj1 <- pedestrians %>%\n  filter(TrajID == 1) %>%\n  dplyr::select(E, N, Datetime_int) %>%\n  as.matrix()\n\n# But instead of repeating these lines 6 times, we turn them into a function.\n# (this is still more repetition than necessary, use the purr::map if you know\n# how!)\n\ndf_to_traj <- function(df, traj) {\n  df %>%\n    filter(TrajID == traj) %>%\n    dplyr::select(E, N, Datetime_int) %>%\n    as.matrix()\n}\n\ntraj2 <- df_to_traj(pedestrians, 2)\ntraj3 <- df_to_traj(pedestrians, 3)\ntraj4 <- df_to_traj(pedestrians, 4)\ntraj5 <- df_to_traj(pedestrians, 5)\ntraj6 <- df_to_traj(pedestrians, 6)\n\n# Then we can start comparing trajectories with each other\n\ndtw_1_2 <- DTW(traj1, traj2)\ndtw_1_3 <- DTW(traj1, traj3)\n\n# ... and so on. Since this also leads to much code repetition, we will\n# demostrate a diffferent approach:\n\n# Instead of creating 6 objects, we can also create a single list containing 6\n# elements by using \"split\" and \"purrr::map\"\n\nlibrary(purrr)\n\npedestrians_list <- map(1:6, function(x) {\n  df_to_traj(pedestrians, x)\n})\n\ncomparison_df <- map_dfr(2:6, function(x) {\n  tibble(\n    trajID = x,\n    DTW = DTW(pedestrians_list[[1]], pedestrians_list[[x]]),\n    EditDist = EditDist(pedestrians_list[[1]], pedestrians_list[[x]]),\n    Frechet = Frechet(pedestrians_list[[1]], pedestrians_list[[x]]),\n    LCSS = LCSS(pedestrians_list[[1]], pedestrians_list[[x]], 5, 4, 4)\n  )\n})\n\nlibrary(tidyr) # for pivot_longer\n\ncomparison_df %>%\n  pivot_longer(-trajID) %>%\n  ggplot(aes(trajID, value, fill = as.factor(trajID))) +\n  geom_bar(stat = \"identity\") +\n  facet_wrap(~name, scales = \"free\") +\n  theme(legend.position = \"none\") +\n  labs(x = \"Comparison trajectory\", y = \"Value\", title = \"Computed similarities using different measures \\nbetween trajectory 1 to all other trajectories \")\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}