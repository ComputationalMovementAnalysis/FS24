{
  "hash": "cbe81b1b3a7087aad6835b21c212d283",
  "result": {
    "markdown": "## Tasks and Inputs\n\n\n\n\n\nYou've read @laube2011 about segmenting trajectories. In the paper, the authors define \"*static*\" fixes as \"*those whose average Euclidean distance to other fixes inside a temporal window v is less than some threshold d*\", as illustrated in the following figure:\n\n![The figure from @laube2011 visualizes steps a) zu d), which will be explained below](../02_Images/laube_2011.jpg){#fig-laubeimg}\n\n(a) Specify a temporal windows $v$ for in which to measure Euclidean distances\n(b) Measure the distance from every point to every other point within this temporal window $v$\n(c) Remove \"static points\": These are points  where the average distance is less than a given threshold. This segments the trajectory into subtrajectories\n(d) Now remove short subtrajectories: These are trajectories with a short duration (whereas \"short\" is tbd)\n\nWe will **demonstrate** implementing this method on the wild boar \"Sabi\", restricting ourselves to a couple of tracking days. Your task will be to understand this implementation and apply it to your own movement data. \n\n\nOpen the RStudio Project [you have prepared](#w3-preparation) for this week. Next, copy the wildboar data you downloaded last week (wildschwein_BE_2056.csv) to your project folder. If you cannot find this dataset on your computer, you can re-download it [here](https://moodle.zhaw.ch/pluginfile.php/1168373/mod_folder/content/0/wildschwein_BE_2056.csv?forcedownload=1)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(\"readr\")\nlibrary(\"dplyr\")\n\nwildschwein <- read_delim(\"datasets/wildschwein_BE_2056.csv\", \",\")\n\nsabi <- wildschwein |>\n    filter(TierName == \"Sabi\", DatetimeUTC >= \"2015-07-01\", DatetimeUTC < \"2015-07-03\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Movement of the wildboar 'Sabi' in the timespan 01 - 02.07.2015. The circle highlingts possible 'static points'](W3_4_tasks_and_inputs_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n#### Step a): Specify a temporal window $v$\n\nIn the above dataset, the sampling interval is 15 minutes. If we take a temporal window of 60 minutes, that would mean including 4 fixes. We need to calculate the following Euclidean distances (pos representing single location):\n\n1. `pos[n-2]` to `pos[n]`\n2. `pos[n-1]` to `pos[n]`\n3. `pos[n]` to `pos[n+1]`\n4. `pos[n]` to `pos[n+2]`\n\n#### Step b): Measure the distance from every point to every other point within this temporal window $v$\n\nJust like last week, we use the formula for calculating the Euclidean distance in in combination with `lead()` and `lag()`. For example, to create the necessary offset of n-2, we use `lag(x, 2)`. For each offset, we create one individual column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsabi <- sabi |>\n    mutate(\n        nMinus2 = sqrt((lag(E, 2) - E)^2 + (lag(N, 2) - N)^2), # distance to pos -30 minutes\n        nMinus1 = sqrt((lag(E, 1) - E)^2 + (lag(N, 1) - N)^2), # distance to pos -15 minutes\n        nPlus1  = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2), # distance to pos +15 mintues\n        nPlus2  = sqrt((E - lead(E, 2))^2 + (N - lead(N, 2))^2) # distance to pos +30 minutes\n    )\n```\n:::\n\n\nNow we want to calculate the mean distance of `nMinus2`, `nMinus1`, `nPlus1`, `nPlus2` for each row. Since we want the mean value *per Row*, we have to explicitly specify this before `mutate()` with the function `rowwise()`. To remove this rowwise-grouping, we end the operation with `ungroup()`. \n\nNote that for the first two positions, we cannot calculate a `stepMean` since there is no Position `n-2` for these positions. This is also true for the last to positions (lacking a position `n+2`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsabi <- sabi |>\n    rowwise() |>\n    mutate(\n        stepMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))\n    ) |>\n    ungroup()\n\nsabi\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 192 × 11\n   TierID TierName CollarID DatetimeUTC                E       N nMinus2 nMinus1\n   <chr>  <chr>       <dbl> <dttm>                 <dbl>   <dbl>   <dbl>   <dbl>\n 1 002A   Sabi        12275 2015-07-01 00:00:10 2570532.  1.21e6    NA      NA  \n 2 002A   Sabi        12275 2015-07-01 00:15:14 2570530.  1.21e6    NA      15.4\n 3 002A   Sabi        12275 2015-07-01 00:30:11 2570676.  1.21e6   159.    155. \n 4 002A   Sabi        12275 2015-07-01 00:45:43 2570707.  1.21e6   177.     63.1\n 5 002A   Sabi        12275 2015-07-01 01:00:20 2570656.  1.21e6    22.0    68.3\n 6 002A   Sabi        12275 2015-07-01 01:15:59 2570850.  1.21e6   144.    204. \n 7 002A   Sabi        12275 2015-07-01 01:31:02 2570819.  1.21e6   173.     31.7\n 8 002A   Sabi        12275 2015-07-01 01:45:37 2570863.  1.21e6   112.    112. \n 9 002A   Sabi        12275 2015-07-01 02:00:17 2570863.  1.21e6   137.     27.1\n10 002A   Sabi        12275 2015-07-01 02:15:13 2570891.  1.21e6    35.5    29.2\n# … with 182 more rows, and 3 more variables: nPlus1 <dbl>, nPlus2 <dbl>,\n#   stepMean <dbl>\n# ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names\n```\n:::\n:::\n\n\n#### Step c): Remove \"static points\"\n\nWe can now determine if an animal is moving or not by specifying a threshold distance on `stepMean`. In our example, we use the mean value as a threshold: Positions with distances below this value are considered static.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsabi <- sabi |>\n    ungroup() |>\n    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))\n\nsabi_filter <- sabi |>\n    filter(!static)\n\nsabi_filter |>\n    ggplot(aes(E, N)) +\n    geom_path() +\n    geom_point() +\n    coord_fixed() +\n    theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![The trajectory of sabi, filtered to the positions where the animal was not static](W3_4_tasks_and_inputs_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n### Preperation\n\nWith the skills from the input above you can now implement the segmentation algorithm described in @laube2011 to your own movement data. Grab your data from last week (or get the most current data from your posmo interface or tracker device) and import it as `data.frame`. Add this data to the .gitignore file to prevent it from being uploaded to GitHub.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"readr\")\nlibrary(\"sf\")\n\nposmo <- read_delim(\"datasets/posmo_2022-05-01T00 00 00+02 00-2023-04-18T23 59 59+02 00.csv\")\n\n# Keep only the necessary columns\nposmo <- select(posmo, datetime, lon_x, lat_y)\n```\n:::\n\n\nAs before, we will calculate the euclidean distance \"by hand\". This means we need the coordinates of our locations stored in a **Projected CRS**. Our data is stored in a geodetic coordinate reference system (WGS84, i.e. EPSG 4326). We can transform the data to EPSG 2056 with the function `st_transform`, as we explained in [the first week](#sec-week1-task3-reproject).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nposmo <- st_as_sf(posmo, coords = c(\"lon_x\",\"lat_y\"), crs = 4326) |>\n  st_transform(2056)\n\nhead(posmo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 6 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2694031 ymin: 1230386 xmax: 2694100 ymax: 1230406\nProjected CRS: CH1903+ / LV95\n# A tibble: 6 × 2\n  datetime                     geometry\n  <dttm>                    <POINT [m]>\n1 2022-11-29 14:42:11 (2694100 1230386)\n2 2022-11-29 16:01:14 (2694100 1230386)\n3 2022-11-29 16:01:14 (2694061 1230396)\n4 2022-11-29 16:01:23 (2694051 1230402)\n5 2022-11-29 16:01:33 (2694040 1230406)\n6 2022-11-29 16:01:42 (2694031 1230401)\n```\n:::\n:::\n\n\nTo be able to compute euclidean distances by hand, we need the coordinates stored in separate columns. The function `st_coordinates` extracts the coordinates from our `sf` object. We can bind these coordinates back to our `sf` object using `cbind`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nposmo_coordinates <- st_coordinates(posmo)\n\nposmo <- cbind(posmo, posmo_coordinates)\n```\n:::\n\n\nExplore your data and choose a single day for the next steps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nposmo_filter <- posmo |>\n    filter(as.Date(datetime) == \"2023-03-23\")\n```\n:::\n\n\nOnce you have completed the task, commit your changes with a meaningful commit message. Before committing, make sure your location data is ignored. Then, test your connection to Github by pushing your changes to your remote repository.\n\n### Task 1: Segmentation\n\nNow, you can implement steps a) b) and c), which you had used with sabi, on on your own movement data. Once you have completed the task, commit your changes with a meaningful commit message and test your connection to Github by pushing your changes to your remote repository.\n\n\n\n\n\n### Task 2: Specify and apply threshold *d*\n\nAfter calculating the Euclidean distances to positions within the temporal window *v* in task 1, you can explore these values (we stored them in the column `stepMean`) using summary statistics (histograms, boxplot, `summary()`): This way we can define a reasonable threshold value to differentiate between *stops* and *moves*. There is no \"correct\" way of doing this, specifying a threshold always depends on data as well as the question that needs to be answered. In this exercise, use the mean of all `stepMean` values.\n\nStore the new information (boolean to differentiate between stops (`TRUE`) and moves (`FALSE`)) in a new column named `static`.\n\nCommit your changes with a meaningful commit message. \n\n\n\n\n\n### Task 3: Visualize segmented trajectories\n\nNow visualize the segmented trajectory spatially. Just like last week, you can use ggplot with `geom_path()`, `geom_point()` and `coord_equal()`. Assign `colour = static` within `aes()` to distinguish between segments *with* \"movement\" and *without*.\n\nCommit your changes with a meaningful commit message. \n\n\n::: {.cell file='solutions/week3/task_3.R'}\n::: {.cell-output-display}\n![](W3_4_tasks_and_inputs_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\n### Task 4: Segment-based analysis\n\nIn applying @laube2011, we've come as far as step b) in @fig-laubeimg. In order to complete the last steps (c and d), we need a *unique* ID for each segment that we can use as a grouping variable. The following function does just that (it assigns unique IDs based on the column `static` which you created in Task 2). You will learn about functions next week. For now, just copy the following code chunk into your script and run it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrle_id <- function(vec) {\n    x <- rle(vec)$lengths\n    as.factor(rep(seq_along(x), times = x))\n}\n```\n:::\n\n\nYou can use the newly created function `rle_id` to assign unique IDs to subtrajectories (as shown below). Visualize the *moving* segments by colourizing them by `segment_ID`. \nThen use `segment_ID` as a grouping variable to determine the segments duration and remove short segments (e.g. segments with a duration < 5 Minutes) \n\nCommit your changes with a meaningful commit message. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nposmo_filter <- posmo_filter |>\n    mutate(segment_id = rle_id(static))\n\nhead(posmo_filter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 6 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2678783 ymin: 1232937 xmax: 2678924 ymax: 1233006\nProjected CRS: CH1903+ / LV95\n                 datetime       X       Y                geometry stepMean\n39774 2023-03-23 07:21:29 2678924 1233006 POINT (2678924 1233006)       NA\n39775 2023-03-23 07:21:29 2678924 1233006 POINT (2678924 1233006)       NA\n39776 2023-03-23 07:21:29 2678924 1233006 POINT (2678924 1233006)       NA\n39777 2023-03-23 07:21:39 2678783 1232937 POINT (2678783 1232937) 137.2258\n39778 2023-03-23 07:21:39 2678783 1232937 POINT (2678783 1232937) 141.1740\n39779 2023-03-23 07:21:39 2678783 1232937 POINT (2678783 1232937) 145.1222\n      static segment_id\n39774     NA          1\n39775     NA          2\n39776     NA          3\n39777   TRUE          4\n39778   TRUE          4\n39779   TRUE          4\n```\n:::\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](W3_4_tasks_and_inputs_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n\n### Task 5: Similarity measures \n\n\nWe will now calculate similarties between trajectories using a new dataset [pedestrian.csv](https://moodle.zhaw.ch/pluginfile.php/1168373/mod_folder/content/0/pedestrian.csv?forcedownload=1). Download an import this dataset as a `data.frame` or `tibble`. It it a set of six different but similar trajectories from pedestrians walking on a path. \n\nFor this task, explore the trajectories first and get an idea on how the pedestrians moved. \n\nCommit your changes with a meaningful commit message. \n\n\n::: {.cell file='solutions/week3/task_5.R'}\n::: {.cell-output-display}\n![](W3_4_tasks_and_inputs_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n### Task 6: Calculate similarity\n\nInstall the package `SimilarityMeasures` (`install.packages(\"SimilarityMeasures\")`). Familiarize yourself with this package by skimming through the function descriptions `help(package = \"SimilarityMeasures\")`. Now compare trajectory 1 to trajectories 2-6 using different similarity measures from the package. Your options are. `DTW`, `EditDist`, `Frechet` and `LCSS`.\n\nBefore visualizing your results think about the following: Which two trajectories to you percieve to be most similar, which are most dissimilar? Now visualize the results from the computed similarity measures. Which measure reflects your own intuition the closest? \n\nNote: \n\n- **All functions in the package need matrices as input, with one trajectory per matrix.**\n- `LCSS`takes very long to compute. The accuracy of the algorithm (`pointSpacing =` ,`pointDistance =` and `errorMarg =`) can be varied to provide faster calculations. Please see @vlachos2002 for more information.\n\nCommit your changes with a meaningful commit message. Now push all your changes to Github.\n\n\n::: {.cell file='solutions/week3/task_6.R'}\n::: {.cell-output-display}\n![](W3_4_tasks_and_inputs_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\n\n### Submission\n\nTo submit your exercise, provide us with the URL of your Github repo as described [in the preperation](#create-github-repo-2).\n\n",
    "supporting": [
      "W3_4_tasks_and_inputs_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}