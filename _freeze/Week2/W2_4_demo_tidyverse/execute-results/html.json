{
  "hash": "21b52b384de9e73797d1484573a01b2d",
  "result": {
    "markdown": "---\nformat:\n  html:\n    code-tools:\n      source: true\n---\n\n\n## Toolskit Demo\n\nDownload this Demoscript via \"\\</\\>Code\" (top right)\n\nDepending on your knowledge of `R`, getting an overview of the data we imported last week might have been quite a challenge. Surprisingly enough, importing, cleaning and exploring your data can be the most challenging, time consuming part of a project. RStudio and the tidyverse offer many helpful tools to make this part easier (and more fun). You have read chapters on `dplyr` and `magrittr` as a preparation for this exercise. Before we start with the exercise however, this demo illustrates a simple approach offered by tidyverse which is applicable to sf-objects.\n\nAssume we want to calculate the timelag between subsequent positions. To achieve this we can use the function `difftime()` combined with `lead()` from `dplyr`. Let's look at these functions one by one.\n\n### `difftime`\n\n`difftime` takes two `POSIXct` values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnow <- Sys.time()\n\nlater <- now + 10000\n\nlater\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-05-11 12:39:54 CEST\"\n```\n:::\n\n```{.r .cell-code}\ntime_difference <- difftime(later, now)\n\ntime_difference\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 2.777778 hours\n```\n:::\n:::\n\n\nYou can also specify the unit of the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime_difference <- difftime(later, now, units = \"mins\")\n\ntime_difference\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 166.6667 mins\n```\n:::\n:::\n\n\n`difftime` returns an object of the Class `difftime`. However in our case, numeric values would be more handy than the Class `difftime`. So we'll wrap the command in `as.numeric()`:\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(time_difference)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"difftime\"\n```\n:::\n\n```{.r .cell-code}\nstr(time_difference)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 'difftime' num 166.666666666667\n - attr(*, \"units\")= chr \"mins\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntime_difference <- as.numeric(difftime(later, now, units = \"mins\"))\n\nstr(time_difference)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num 167\n```\n:::\n\n```{.r .cell-code}\nclass(time_difference)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n### `lead()` / `lag()`\n\n`lead()` and `lag()` return a vector of the same length as the input, just offset by a specific number of values (default is 1). Consider the following sequence:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- 1:10\n\nnumbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\nWe can now run `lead()` and `lag()` on this sequence to illustrate the output. `n =` specifies the offset, `default =` specifies the default value used to \"fill\" the emerging \"empty spaces\" of the vector. This helps us performing operations on subsequent values in a vector (or rows in a table).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"dplyr\")\n\nlead(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2  3  4  5  6  7  8  9 10 NA\n```\n:::\n\n```{.r .cell-code}\nlead(numbers, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  4  5  6  7  8  9 10 NA NA\n```\n:::\n\n```{.r .cell-code}\nlag(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] NA  1  2  3  4  5  6  7  8  9\n```\n:::\n\n```{.r .cell-code}\nlag(numbers, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] NA NA NA NA NA  1  2  3  4  5\n```\n:::\n\n```{.r .cell-code}\nlag(numbers, n = 5, default = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 0 0 0 0 1 2 3 4 5\n```\n:::\n:::\n\n\n### `mutate()`\n\nUsing the above functions (`difftime()` and `lead()`), we can calculate the time lag, that is, the time difference between consecutive positions. We will try this on a dummy version of our wildboar dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein <- tibble(\n    TierID = c(rep(\"Hans\", 5), rep(\"Klara\", 5)),\n    DatetimeUTC = rep(as.POSIXct(\"2015-01-01 00:00:00\", tz = \"UTC\") + 0:4 * 15 * 60, 2)\n)\n\nwildschwein\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n   TierID DatetimeUTC        \n   <chr>  <dttm>             \n 1 Hans   2015-01-01 00:00:00\n 2 Hans   2015-01-01 00:15:00\n 3 Hans   2015-01-01 00:30:00\n 4 Hans   2015-01-01 00:45:00\n 5 Hans   2015-01-01 01:00:00\n 6 Klara  2015-01-01 00:00:00\n 7 Klara  2015-01-01 00:15:00\n 8 Klara  2015-01-01 00:30:00\n 9 Klara  2015-01-01 00:45:00\n10 Klara  2015-01-01 01:00:00\n```\n:::\n:::\n\n\n\nTo calculate the `timelag` with base-R, we need to mention `wildschwein` three times \n\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein$timelag <- as.numeric(difftime(lead(wildschwein$DatetimeUTC), wildschwein$DatetimeUTC))\n```\n:::\n\n\nUsing `mutate()` we can simplify this operation slightly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein <- mutate(wildschwein, timelag = as.numeric(difftime(lead(DatetimeUTC), DatetimeUTC)))\n\nwildschwein\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n   TierID DatetimeUTC         timelag\n   <chr>  <dttm>                <dbl>\n 1 Hans   2015-01-01 00:00:00      15\n 2 Hans   2015-01-01 00:15:00      15\n 3 Hans   2015-01-01 00:30:00      15\n 4 Hans   2015-01-01 00:45:00      15\n 5 Hans   2015-01-01 01:00:00     -60\n 6 Klara  2015-01-01 00:00:00      15\n 7 Klara  2015-01-01 00:15:00      15\n 8 Klara  2015-01-01 00:30:00      15\n 9 Klara  2015-01-01 00:45:00      15\n10 Klara  2015-01-01 01:00:00      NA\n```\n:::\n:::\n\n\n### `group_by()`\n\nYou might have noticed that `timelag` is calculated across different individuals (`Hans` and `Klara`), which does not make much sense. \nTo avoid this, we need to specify that `timelag` should just be calculated between consecutive rows *of the same individual*. We can implement this by using `group_by()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein <- group_by(wildschwein, TierID)\n```\n:::\n\n\nAfter adding this grouping variable, calculating the `timelag` automatically accounts for the individual trajectories.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein <- mutate(wildschwein, timelag = as.numeric(difftime(lead(DatetimeUTC), DatetimeUTC)))\n\nwildschwein\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n# Groups:   TierID [2]\n   TierID DatetimeUTC         timelag\n   <chr>  <dttm>                <dbl>\n 1 Hans   2015-01-01 00:00:00      15\n 2 Hans   2015-01-01 00:15:00      15\n 3 Hans   2015-01-01 00:30:00      15\n 4 Hans   2015-01-01 00:45:00      15\n 5 Hans   2015-01-01 01:00:00      NA\n 6 Klara  2015-01-01 00:00:00      15\n 7 Klara  2015-01-01 00:15:00      15\n 8 Klara  2015-01-01 00:30:00      15\n 9 Klara  2015-01-01 00:45:00      15\n10 Klara  2015-01-01 01:00:00      NA\n```\n:::\n:::\n\n\n### `summarise()`\n\nIf we want to summarise our data and get metrics *per animal*, we can use the `dplyr` function `summarise()`. In contrast to `mutate()`, which just adds a new column to the dataset, `summarise()` \"collapses\" the data to one row per individual (specified by `group_by`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(wildschwein, mean = mean(timelag, na.rm = T))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  TierID  mean\n  <chr>  <dbl>\n1 Hans      15\n2 Klara     15\n```\n:::\n:::\n\n\nNote: You can do `mutate()` and `summarise()` on `sf` objects as well. However, `summarise()` tries to coerce all geometries into one object, which can take along time. To avoid this, use `st_drop_geometry()` before using `summarise()`. \n\n### Piping \n\nThe code above may be a bit hard to read, since it has so many nested functions which need to be read from the inside out. In order to make code readable in a more human-friendly way, we can use the piping command `|>` from `magrittr`, which is included in `dplyr` and the `tidyverse`. The above code then looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein |> # Take wildschwein...\n    group_by(TierID) |> # ...group it by TierID\n    summarise( # Summarise the data...\n        mean_timelag = mean(timelag, na.rm = T) # ...by calculating the mean timelag\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  TierID mean_timelag\n  <chr>         <dbl>\n1 Hans             15\n2 Klara            15\n```\n:::\n:::\n\n\n### Bring it all together...\n\nHere is the same approach with a different dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npigs <- tibble(\n    TierID = c(8001, 8003, 8004, 8005, 8800, 8820, 3000, 3001, 3002, 3003, 8330, 7222),\n    sex = c(\"M\", \"M\", \"M\", \"F\", \"M\", \"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"F\"),\n    age = c(\"A\", \"A\", \"J\", \"A\", \"J\", \"J\", \"J\", \"A\", \"J\", \"J\", \"A\", \"A\"),\n    weight = c(50.755, 43.409, 12.000, 16.787, 20.987, 25.765, 22.0122, 21.343, 12.532, 54.32, 11.027, 88.08)\n)\n\npigs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 4\n   TierID sex   age   weight\n    <dbl> <chr> <chr>  <dbl>\n 1   8001 M     A       50.8\n 2   8003 M     A       43.4\n 3   8004 M     J       12  \n 4   8005 F     A       16.8\n 5   8800 M     J       21.0\n 6   8820 M     J       25.8\n 7   3000 F     J       22.0\n 8   3001 F     A       21.3\n 9   3002 M     J       12.5\n10   3003 F     J       54.3\n11   8330 M     A       11.0\n12   7222 F     A       88.1\n```\n:::\n\n```{.r .cell-code}\npigs |>\n    summarise(\n        mean_weight = mean(weight)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  mean_weight\n        <dbl>\n1        31.6\n```\n:::\n\n```{.r .cell-code}\npigs |>\n    group_by(sex) |>\n    summarise(\n        mean_weight = mean(weight)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  sex   mean_weight\n  <chr>       <dbl>\n1 F            40.5\n2 M            25.2\n```\n:::\n\n```{.r .cell-code}\npigs |>\n    group_by(sex, age) |>\n    summarise(\n        mean_weight = mean(weight)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n# Groups:   sex [2]\n  sex   age   mean_weight\n  <chr> <chr>       <dbl>\n1 F     A            42.1\n2 F     J            38.2\n3 M     A            35.1\n4 M     J            17.8\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}