{
  "hash": "871211f19894bcbf8db66efbcb211a23",
  "result": {
    "markdown": "## Demo Tidyverse (R-Code)\n\n:::{.callout-tip}\nHover over the code and copy the content by clicking on the clipboard icon on the top right. You can now paste this into an R-Script.\n:::\n\n\n::: {.cell file='Week2/W2_4_demo_tidyverse.qmd'}\n\n```{.r .cell-code}\n## Demo Tidyverse\n\n[Download the code as an Rmd-File](W2_4_demo_tidyverse.qmd)\n\nDepending on your knowledge of `R`, getting an overview of the data we imported last week might have been quite a challenge. Surprisingly enough, importing, cleaning and exploring your data can be the most challenging, time consuming part of a project. RStudio and the tidyverse offer many helpful tools to make this part easier (and more fun). You have read chapters on `dplyr` and `magrittr` as a preparation for this exercise. Before we start with the exercise however, this demo illustrates a simple approach offered by tidyverse which is applicable to sf-objects.\n\nAssume we want to calculate the timelag between subsequent positions. To achieve this we can use the function `difftime()` combined with `lead()` from `dplyr`. Let's look at these functions one by one.\n\n### `difftime`\n\n`difftime` takes two `POSIXct` values.\n\n```{r}\nnow <- Sys.time()\n\nlater <- now + 10000\n\nlater\n\ntime_difference <- difftime(later, now)\n\ntime_difference\n```\n\nYou can also specify the unit of the output.\n\n```{r}\ntime_difference <- difftime(later, now, units = \"mins\")\n\ntime_difference\n```\n\n`difftime` returns an object of the Class `difftime`. However in our case, numeric values would be more handy than the Class `difftime`. So we'll wrap the command in `as.numeric()`:\n```{r}\nclass(time_difference)\n\nstr(time_difference)\n```\n\n```{r}\ntime_difference <- as.numeric(difftime(later, now, units = \"mins\"))\n\nstr(time_difference)\nclass(time_difference)\n```\n\n### `lead()` / `lag()`\n\n`lead()` and `lag()` return a vector of the same length as the input, just offset by a specific number of values (default is 1). Consider the following sequence:\n\n```{r}\nnumbers <- 1:10\n\nnumbers\n```\n\nWe can now run `lead()` and `lag()` on this sequence to illustrate the output. `n =` specifies the offset, `default =` specifies the default value used to \"fill\" the emerging \"empty spaces\" of the vector. This helps us performing operations on subsequent values in a vector (or rows in a table).\n\n```{r}\nlibrary(dplyr)\n\nlead(numbers)\n\nlead(numbers, n = 2)\n\nlag(numbers)\n\nlag(numbers, n = 5)\n\nlag(numbers, n = 5, default = 0)\n```\n\n### `mutate()`\n\nUsing the above functions (`difftime()` and `lead()`), we can calculate the time lag, that is, the time difference between consecutive positions. We will try this on a dummy version of our wildboar dataset.\n\n```{r}\nwildschwein <- tibble(\n  TierID = c(rep(\"Hans\", 5), rep(\"Klara\", 5)),\n  DatetimeUTC = rep(as.POSIXct(\"2015-01-01 00:00:00\", tz = \"UTC\")+0:4*15*60, 2)\n  )\n\nwildschwein\n```\n\n\nTo calculate the `timelag` with base-R, we need to mention `wildschwein` three times \n\n```{r}\nwildschwein$timelag  <- as.numeric(difftime(lead(wildschwein$DatetimeUTC), wildschwein$DatetimeUTC))\n```\n\nUsing `mutate()` we can simplify this operation slightly:\n\n```{r}\nwildschwein <- mutate(wildschwein,timelag = as.numeric(difftime(lead(DatetimeUTC), DatetimeUTC)))\n\nwildschwein\n```\n\n### `group_by()`\n\nYou might have noticed that `timelag` is calculated across different individuals (`Hans` and `Klara`), which does not make much sense. \nTo avoid this, we need to specify that `timelag` should just be calculated between consecutive rows *of the same individual*. We can implement this by using `group_by()`. \n\n```{r}\nwildschwein <- group_by(wildschwein, TierID)\n```\n\nAfter adding this grouping variable, calculating the `timelag` automatically accounts for the individual trajectories.\n\n```{r}\nwildschwein <- mutate(wildschwein, timelag = as.numeric(difftime(lead(DatetimeUTC), DatetimeUTC)))\n\nwildschwein\n```\n\n### `summarise()`\n\nIf we want to summarise our data and get metrics *per animal*, we can use the `dplyr` function `summarise()`. In contrast to `mutate()`, which just adds a new column to the dataset, `summarise()` \"collapses\" the data to one row per individual (specified by `group_by`).\n\n```{r}\nsummarise(wildschwein, mean = mean(timelag, na.rm = T))\n```\n\nNote: You can do `mutate()` and `summarise()` on `sf` objects as well. However, `summarise()` tries to coerce all geometries into one object, which can take along time. To avoid this, use `st_drop_geometry()` before using `summarise()`. \n\n### Piping \n\nThe code above may be a bit hard to read, since it has so many nested functions which need to be read from the inside out. In order to make code readable in a more human-friendly way, we can use the piping command `|>` from `magrittr`, which is included in `dplyr` and the `tidyverse`. The above code then looks like this:\n\n```{r}\nwildschwein |>                              # Take wildschwein...\n  group_by(TierID) |>                       # ...group it by TierID\n  summarise(                                # Summarise the data...\n    mean_timelag = mean(timelag, na.rm = T) # ...by calculating the mean timelag\n  )\n```\n\n### Bring it all together...\n\nHere is the same approach with a different dataset:\n\n```{r}\npigs <- tibble(\n  TierID = c(8001,8003,8004,8005,8800,8820,3000,3001,3002,3003,8330,7222),\n  sex = c(\"M\",\"M\",\"M\",\"F\",\"M\",\"M\",\"F\",\"F\",\"M\",\"F\",\"M\",\"F\"),\n  age= c (\"A\",\"A\",\"J\",\"A\",\"J\",\"J\",\"J\",\"A\",\"J\",\"J\",\"A\",\"A\"),\n  weight = c(50.755,43.409,12.000,16.787,20.987,25.765,22.0122,21.343,12.532,54.32,11.027,88.08)\n)\n\npigs\n\npigs |>\n    summarise(         \n      mean_weight = mean(weight)\n    )\n\npigs |>\n  group_by(sex) |>\n  summarise(         \n    mean_weight = mean(weight)\n  )\n\npigs |>\n  group_by(sex, age) |>\n  summarise(         \n    mean_weight = mean(weight)\n  )\n```\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}